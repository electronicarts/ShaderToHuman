<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="ConfiguratorJS.css">
    <script src="utils/parser.js"></script>
    <script src="utils/backends.js"></script>
    <script type="text/javascript" src="ConfiguratorJS.js"></script>
    <script type="text/javascript" src="GenMath.js"></script>
    <script type="text/javascript" src="ConfiguratorBackend.js"></script>
    <script src='https://git.io/glm-js.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <meta name="description" content="A HLSL/GLSL library for debugging shaders, includes HTML documentation and examples you can run with Gigi and WebGL.">

    <title>Shader To Human (S2H)</title>

    <script>
        let initialStartup = true;
        function knowledge_Main() {
            validConfig.add("Tabs"); // to prevent assert, hacky?

            // set some good defaults
            if(initialStartup) {
                initialStartup = false;

                set("Code", "HLSL");
                set("Tabs", "What is S2H");
                set("Gather", "printTxt");
                set("Scatter", "init");
                set("2D", "disc");
                set("3D", "checkerBoard");
                set("UI", "button");
            }

            //            if(!get("Tabs"))
            {
//                set("Tabs", "HLSLInputCode");
//                set("Tabs", "Sandbox");
            }

            knowledge_GenMath(); 
        }

        // optional callback for first time AFTER page is there, can call onConfigButton()
        function onFirstTime() {
            // for convenience during development, we choose a config to show up by default
//            onConfigButton("ShaderToy GLSL");
        }

        const shaderPaths = [
        ];
        loadMultipleHLSLFiles(shaderPaths); // TODO: Inefficient? This loads the shader files on every page refresh. Cache?

        // case sensitive
        // @param choices e.g. "What is S2H|Get Started|Gather|Scatter|2D|3D|UI|UnitTest|Sandbox"
        // @return index or -1
        function computeIndexInString(key, choices) {
            const choiceValueArray = choices.split("|");
            return choiceValueArray.indexOf(key);
        }

        function knowledge_GenMath() {

            if(typeof s2h === 'undefined')
            {
                logError("Please don't run this html page locally, start startLocalServer.bat.");
                return;
            }

//            option("Code", null, "GLM|CSharp|HLSL|GLSL|UnrealC++|glm-js");
            // for now we only support this but we might add more later e.g. "CUDA"
            option("Code", null, "HLSL|GLSL");

            // "Sandbox " disabled until we fix the remaining issues
//            tab("Tabs", null, "What is S2H|Get Started|Gather|Scatter|2D|3D|UI|UnitTest|Sandbox|Integration|License");
            tab("Tabs", null, "What is S2H|Get Started|Gather|Scatter|2D|3D|UI|UnitTest|Integration|License");
            
            var generateCode = true;                     logText("");

            if (generateCode && !genSetup(get("Code")))
            {
                logError("Please specify a valid 'Code' backend.");
                return;
            }


            if (get("Tabs") == null) {

                logText("TODO: introtext");
                logText("Clip on one of the tabs above to see the content.");
                generateCode = false;
            }

            if (get("Tabs") == "What is S2H") {
                logH2("Shader 2 Human (S2H) - a HLSL/GLSL library for debugging shaders");
                logText("");
                logText(
                    "This easy to integrate (soon open source) tool is designed to help engineers with shader writing and debugging." + 
                    "Documentation and examples get you started quickly. Working best in a shader hot reloading environment like Gigi," +
                    "rapid prototyping becomes straightforward.");
                logText(
                    "Integration in your codebase is easy and you can use it for PrintF debugging, draw 2d and 3d shapes with few" +
                    " lines of code. No C++ code changes required.");             
                logLink("Gigi", "https://github.com/electronicarts/gigi");
                logLink("Shadertoy", "https://www.shadertoy.com");
                logText("");
                logH2("The name");
                logText("As software developer we are used to have good debuggers allowing us to inspect the internals like memory and variables.");
                logText(
                    "The GPU is usually driven by a CPU and getting back anything is cumbersome. This library is connecting the two worlds, from 'Shader to Human'.");
                logText(
                    "All library code starts with 's2h_'. This avoids collisions with existing code without requiring features like namespace." +
                    "With S2H you can inspect variables and visualize 2D and 3D internals. Most 3D engines provide such tools but often they have" +
                    "been written for a specific subsystem and are quite rigid.");
                logText("");
                logH2("Simple by design");
                logText(
                    "S2H is shader code only, easy to integrate (#include + 3 lines) and use (single line to print a float)." +
                    "The performance is good enough for debugging and simple experiments but nothing more. This is by design." +
                    "It's a tool you can quickly use to inspect a problem and then remove so it's not meant to replace all tooling needs. " + 
                    "To ease cross platform developemnt (namely using GLSL) we adopted ac code style suitable for all platforms. " + 
                    "This is why we don't use templates, default arguments, use the correct types and cross a cross platfrom type cast." + 
                    "This is also why we use functions with a s2h_ prefix  over methods and name spaces.");
                generateCode = false;
            }

            if (get("Tabs") == "Get Started") {
                
                logH2("Installation for hlsl (Direct X shader language)");
                logText(
                    "Simpliy put the .hlsl files in the 'include' folder in a place you can access from your shader. " +
                    "The main include is 's2h.hlsl'.");
                logH2("Installation for glsl (OpenGL / Vulkan shader language)");
                logText("Depending on your environmet you can choose from these 3 options:");
                logText("a) Include 's2h_glsl.hlsl' first, then include the '.hlsl' as before.");
                logText("b) Include the .glsl files in the 'public/include' files.");
                logText("c) Copy the the content of the preconverted .glsl files (public/include folder) to a common place or in front of your own shader code.");
                logH2("A simple example");
                logText("");
                logText("Look at the top of the include files to copy a few lines to setup the library. Here is a simplex example:");

                getPrettyCodeFile("public/docs/intro_0.hlsl");
                genCanvas("3D", 0, 480, 100);
            }
            
            if (get("Tabs") == "Integration") {
                logText("");
                logText("There are multiple option to integrate S2H:");
                
                logImage("images/IntegrationOptions.png", "Integration Options");

                logH2("Shadertoy");
                logText(
                    "Copy the the content of the preconverted .glsl files (public/include folder) to the \"Common\" tab. " +
                    "You need \"s2h.glsl\" and if you want 3D then also \"s2h_3d.glsl\".");
                logLink("Shadertoy", "https://www.shadertoy.com");

                logH2("Gigi");
                logText(
                    "Copy the the content of the preconverted .glsl files (public/include folder) into your technique folder. " +
                    "It's best to use a subfolder \"s2h/include\". This way you can have the full s2s folder structure there as documentation and you can look at the examples.");
                logLink("Gigi", "https://github.com/electronicarts/gigi");

                logH2("OpenGL vs DirectX math");
                logText("The library source is written in HLSL (DirectX) but can be used with GLSL (OpenGL, Vulkan) as well. " + 
                    "Both APIs have different coordinate systems and math order. To unify both, you have to chose a standard and convert for the used API.<br>" +
                    "S2H is using the common OpenGL style math, also called post-multiplication (e.g. model = translate * rotate * scale; world_pos = model * local_pos).<br>" +
                    "This is also applies for the handyness: S2H uses a right handed coordinate system with positive Z is the view direction.<br>" +
                    "S2H is also using the DirectX style 2D pixel coordinate system (Y is down, not up, 0, 0 is left top, +0.5 to be pixel centered).<br>" +
                    "This also applies for UV coordinates (V is down, 0,0 is left top). ");
                logText(
                    "To make it work for an environment where that is not the case you have to adapt your input / setup code. " +
                    "You can look for the setup code samples in HLSL and GLSL.");
                    logLink("Tim Sweeney on Unreal moving to a new coordinate system.", "https://x.com/TimSweeneyEpic/status/1930678660098408669");

                generateCode = false;
            }

            if (get("Tabs") == "License") {
                logText("");
                logText("Copyright (c) 2024 Electronic Arts Inc. All rights reserved.");
                logText("Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:");
                logText("1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.");
                logText("2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.");
                logText("3.  Neither the name of Electronic Arts, Inc. (\"EA\") nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.");
                logText("4.  EAâ€™s marks or logos, including SEED logos, are distributed with this software solely for demonstration purposes and may not be displayed or shared other than as part of a redistribution of this software, provided they are redistributed without modification.  No other rights are provided for the use of these marks and logos, other than for their intended demonstration purposes.");
                logText("THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.");
                generateCode = false;
            }

            if (get("Tabs") == "Gather") {
                let subElements = "init|printTxt|printInt|printHex|printFloat|printShapes|progress";
                tab("Gather", null, subElements);
                let subIndex = computeIndexInString(get("Gather"), subElements);
                if(subIndex >= 0)
                {
                    if (get("Gather") == "init") {
                        logH2("When to use Gather");

                        logText("todo CS(uint2 DTid : SV_DispatchThreadID), PS(SV_Position), FS(OpenGL)");
                    }

                    let fileName = "public/docs/gather_docs_" + subIndex + ".hlsl";
                    // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                    getPrettyCodeFile(fileName);
                    genCanvas("3D", 0, 480, 100);
                }
            }
            if (get("Tabs") == "Scatter") {
                let subElements = "init|setCursor|printTxt|printDatatype|shapes|crosshair";
                tab("Scatter", null, subElements);

                if (get("Scatter") == "init") {
                    logH2("When to use Scatter");
                    logText(
                        "'Gather' works well for mosty use cases but sometimes you need a different tool. 'Scatter' provides a simialar API but with a different implementation. " +
                        "Printing data with 'Gather' requires you to provide the same input for all pixels that will show the number, otherwise you get scrambled results. In many " +
                        "cases you can ensure this is the case. When that is not possible you can print data from a single thread. But GPUs always execute many more threads than CPUs. " +
                        "To avoid heavy overdraw (slow, unreadable) it's best to filter the function call (if) to only execute for the specific case you need it to be. If you still " +
                        "want to inspect multiple thread you have to offset then in X or Y based on the thread (or lane) id." 
                    );
                    logH2("When you cannot use Scatter");
                    logText(
                        "For need to scatter / poke a color to a 2D buffer / Texture / UAV. This is a common operation for Compute Shaders but might not be available for older graphics APIs. " +
                        "All modern GPUs have that feature but the WebGL API is lacking the support."
                    );
                    logH2("How to use Scatter");
                    logText("TODO function onGfxForAllScatter");
                }

                let subIndex = computeIndexInString(get("Scatter"), subElements);
                if(subIndex >= 0)
                {
                    let fileName = "public/docs/Scatter_docs_" + subIndex + ".hlsl";
                    // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                    getPrettyCodeFile(fileName);
                }
            }
            if (get("Tabs") == "2D") {
                let subElements = "init|disc|circle|halfSpace|rectangle|rectangleAA|crosshair|line|sRGBRamp|arrow|triangle";
                tab("2D", null, subElements);

                if (get("2D") == "sRGBRamp") {
                    logText("s2h_sRGBRamp() is useful to verify the colors are processed in the correct color space.");
                    logText(
                        "The greyscale value should transition from 0 to 255 in 256 pixels without skipping colors. " +
                        "The colorful thin outer border has a gradient from red over green to blue. This is useful to verify" + 
                        "the color channels are not mixed up.");
                }

                let subIndex = computeIndexInString(get("2D"), subElements);
                if(subIndex >= 0)
                {
                    let fileName = "public/docs/2D_docs_" + subIndex + ".hlsl";
                    // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                    getPrettyCodeFile(fileName);
                    genCanvas("3D", 0, 480, 100);
                }
            }
            if (get("Tabs") == "3D") {
                let subElements = "checkerBoard|sphere|line|arrow|basis|AABB";
                tab("3D", null, subElements);
                let subIndex = computeIndexInString(get("3D"), subElements);
                logText("");

                if (get("3D") == "checkerBoard") {
                    logText("s2h_drawcheckerBoard() is useful to have world space scale reference and as a basis for experiments.");
                    logText(
                        "Each checker board tile is unit length and you can see a flat basis (x:red, y:green, z:blue) on the board. " + 
                        "The checkerboard is a great starting point to verify the ray tracing math is setup correctly.");
                }
                if (get("3D") == "line") {
                    logText(
                        "s2h_drawLine() places a cylinder between 2 given points. The cylinder radius can be specified too.");
                }
                if (get("3D") == "basis") {
                    logText(
                        "s2h_drawBasis() can be used to visualize a object transform (rotation, scale, mirror, translation, skew). " +
                        "The 5 basis vectors here all point (z axis) to the same world space point and have the same up vector (Y axis). " +
                        "The length or the arrows indicate no scale and the orthogonal vectors show no skew. All basis are right handed " +
                        "and are located on a circle looking down at the point.");
                }

                if(subIndex >= 0)
                {
                    let fileName = "public/docs/3D_docs_" + subIndex + ".hlsl";
                    // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                    getPrettyCodeFile(fileName);
                    genCanvas("3D", 0);
                }
            }

            if (get("Tabs") == "UI") {
                let subElements = "button|radioButton|checkBox|sliderFloat|sliderRGB|sliderRGBA|tables";
                tab("UI", null, subElements);
                logText("");
                logText("The WebGL code here does not support interactive UI yet. See the Gigi examples work more.");
                let subIndex = computeIndexInString(get("UI"), subElements);
                if(subIndex >= 0)
                {
                    let fileName = "public/docs/UI_docs_" + subIndex + ".hlsl";
                    // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                    getPrettyCodeFile(fileName);
                    genCanvas("2D", 0, 480, 100);
                }
            }

            if (get("Tabs") == "UnitTest") {
                logText("");
                logText(
                    "The screen shot comparison tests for HLSL are implement in unittests/s2h_unittests.gg which yiou cna open with Gigi. " + 
                    "Run the automated test by run the Python file GigiTest.py the same folder. The log with report success if all images match " +
                    "with the gold images. Minor GPU and driver differences could make this fail. When that happen we might have to look into improving it.");
                generateCode = false;
            }

            if (get("Tabs") == "Sandbox") {
                logText("The Sandbox offers a simple text editor in the next UI element.");
                logText("The text is assumed to be HLSL and transpiled to the requested langage below.");
                logText("Another version transpiled to glsl is rendered in the screen to the left.");
                logText("Move the slider there to see the effect of \"iTime\".");
                
                genFileList();
                // create Text editor UI, the data is stored in g_TextEditorContent
                genTextEditor();
                // setup so the next call to getBackendCode("GLSL") by genCanvas() creates the right code
                genBackends(g_TextEditorContent, g_TextEditorContent);
                genCanvas("2D", 0);
            }

            if(generateCode) {
//            logCode(g_imTxt);
                const backendCode = getBackendCode(g_CodeType);
                if(backendCode !== undefined)
                    logCode(backendCode);

                if (g_CodeType === "glm-js") {
                    genCanvas("2D", 0);
                }
            }
        }


        // ------------------

    </script>

</head>
<body>
    <!-- 
    <script class="HLSLInputCode" name="sample.hlsl" type="notjs">
        // sample HLSL code
        float func(float x)
        {
            return sin(x);
        }
    </script>
    -->

    <!-- The following elements are data elements and will not be shown in the HTML directly,
             they get extracted by the Java Script code and used in other ways. -->

    <!-- 
    <code class="ConfiguratorState" name="X">
        Comments = true
    </code>

    <code class="ConfiguratorState" name="Gigi HLSL">
        # https://github.com/electronicarts/gigi
        Comments = true
        Code = HLSL
        WorldUp = Y
        WorldUnit = cm
        WorldHandedness = left
        ObjectHandedness = both
        TransformationNamingConvention = to
        ViewportY = down
        TextureY = down
    </code>

    <code class="ConfiguratorState" name="ShaderToy GLSL">
        # todo
        Comments = true
        Code = GLSL
        ObjectTransform = None
        MatrixMemoryLayout = column-major
        TextureY = up
    </code>
-->
</body>


</html>
