
// Allows us to import in both HTML and NodeJS
if (typeof exports == "undefined") {
    exports = this;
}

if(typeof parse === 'undefined'){
    var parser = require('./parser.js');
    var parse = parser.parse;
}

class IBackend {
    constructor() {
        this.code = "";
        this.typeMap = {};
    }

    genRetType = type => {
        if (type in this.typeMap) {
            return this.typeMap[type];
        }

        return undefined;
    }

    clear = () => this.code = "";

    getTransposeFunc = () => 'transpose';

    // @param fileName string for debugging, may be null
    genCode(txt, fileName) {
    }


    translateName = type => this.genRetType(type);
}

class BackendGLM extends IBackend {
    constructor() {
        super();
        this.typeMap = {
            "float2x2": "glm::mat2",
            "float3x3": "glm::mat3",
            "float4x4": "glm::mat4",
            "float": "float",
            "float2": "glm::vec2",
            "float3": "glm::vec3",
            "float4": "glm::vec4",
            "int2": "glm::ivec2",
            "int3": "glm::ivec3",
            "int4": "glm::ivec4",
            "uint2": "glm::uvec2",
            "uint3": "glm::uvec3",
            "uint4": "glm::uvec4",
            "quat": "glm::quat"
        };
    }

    genCode(txt, fileName) {
    }

}


class BackendGLMJS extends IBackend {
    constructor() {
        super();
        this.typeMap = {
            "float2x2": "glm.mat2",
            "float3x3": "glm.mat3",
            "float4x4": "glm.mat4",
            "float": "float",
            "float2": "glm.vec2",
            "float3": "glm.vec3",
            "float4": "glm.vec4",
            "int2": "glm.ivec2",
            "int3": "glm.ivec3",
            "int4": "glm.ivec4",
            "uint2": "glm.uvec2",
            "uint3": "glm.uvec3",
            "uint4": "glm.uvec4",
            "quat": "glm.quat"
        };
    }

    genCode(txt, fileName) {
    }
}

class BackendPassthrough extends IBackend {
    constructor() {
        super();
    }
    // Default backend is HLSL, so return as is.
    translateName = type => type;
    genRetType = type => type;

    genCode(txt, fileName) {
        console.assert(txt !== undefined);
        this.code = "";
//        this.code += "// generated by BackendPassthrough\n";
        this.code += parse(txt, new BackendPassthrough(), fileName);
    }
}

class BackendGLSL extends IBackend {
    constructor() {
        super();
        
        // We have preprocesssed .glsl files already 
        this.typeMap = {};
    /*
        this.typeMap = {
            "float2x2": "mat2",
            "float3x3": "mat3",
            "float4x4": "mat4",
            "float": "float",
            "float2": "vec2",
            "float3": "vec3",
            "float4": "vec4",
            "int2": "ivec2",
            "int3": "ivec3",
            "int4": "ivec4",
            "uint2": "uvec2",
            "uint3": "uvec3",
            "uint4": "uvec4",
            "frac": "fract",
            "lerp": "mix",
            "rsqrt": "inversesqrt"
        };
        */
    }

    genCode(txt, fileName) {
        console.assert(txt !== undefined);
//        this.code += "// generated by BackendGLSL\n";
        this.code += parse(txt, new BackendGLSL(), fileName);
    }
}

// like Backend_GLSL but expands #include
class BackendWebGL extends BackendGLSL {
    constructor() {
        super();
    }
    genCode(txt, fileName) {
        console.assert(txt !== undefined);
        let backend = new BackendWebGL();
        backend.expandIncludes = true;
        this.code = "";
//        this.code += "// generated by BackendWebGL\n";
        this.code += parse(txt, backend, fileName);
    }
}

// available backends to be usable by s2h.getBackend()
const gBackends = {
    'hlsl': new BackendPassthrough(),
    // We have preprocesssed .glsl files already 
//    'glsl': new BackendGLSL(),
    'glsl': new BackendPassthrough(),
    'glm': new BackendGLM(),
    'webgl': new BackendWebGL(),
    'glm-js': new BackendGLMJS(),
    'none': new IBackend()
};

// stores a dictionary of backends for different code types
const s2h = {
    getBackend: (codeType) => {
        codeType = codeType.toLowerCase();
        if (codeType in gBackends) {
            return gBackends[codeType];
        }

        const nonBackend = 'none';
        return gBackends[nonBackend];
    },
    getBackendList: () => Object.keys(gBackends)
};

exports.s2h = s2h;